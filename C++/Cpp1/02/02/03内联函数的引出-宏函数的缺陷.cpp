//
//  03内联函数的引出-宏函数的缺陷.cpp
//  02
//
//  Created by xiaoyuan on 2018/11/19.
//  Copyright © 2018 xiaoyuan. All rights reserved.
//

#include <iostream>

/*
 C++---内联函数和宏函数的优缺点
 内联函数
 内联函数是C++为提高程序运行速度进行的改进，是一种以空间换时间的做法。
 
 内联函数与常规函数
 
 常规函数
 
 运行程序时，常规函数调用会使程序跳到另一个地址（函数地址），并在函数结束时返回。
 详细过程：执行到函数调用指令时，程序将在函数调用后立即存储该指令的内存地址，并将函数参数复制到堆栈（为此保留的内存块），跳到标记函数起点的内存单元，执行函数代码（也许还需要将返回值放入寄存器中），然后跳回到地址被保存的指令处。来回跳跃并记录跳跃位置意味着以前使用函数时，需要一定的开销。
 
 内联函数
 
 内联函数的编译代码与其他程序代码“内联”起来了。也就是说，编译器将使用相应的函数代码替换函数调用。
 对于内联函数，程序无需跳到另一个位置处执行代码，再跳回来。因此，内联函数的运行速度比常规函数快，但代价是需要占用更多的内存。
 在使用内联函数时，如果调用函数的时间比处理函数的时间长，节省的时间占大头。但如果调用时间小于处理函数的时间短，则没有必要使用内联函数。
 
 要使用内联函数的特性：
 需要在函数前加上关键字inline，但inline是建议性关键字，当请求将函数作为内联函数时，编译器并不一定会满足这种要求。内联函数尽量避免函数体过长、含有循环、递归。
 
 内联与宏
 
 内联函数的优势在于做参数类型检查，而宏定义不会，宏只是简单的文本替换。
 #define SQUARE(X) X*X
 
 a = SQUARE(5.0); // a = 5.0 * 5.0
 b = SQUARE(4.3 + 3.1); // 4.3 + 3.1 * 4.3 + 3.1
 c = SQUARE(d++) // c == d++ * d++ d递增两次

 宏定义时不能忘记括号的使用，否则会造成运算错误。但是上述代码中，加上括号仍然会出现错误，在第三个函数中，d依旧递增两次。如果使用内联函数，则是计算出 d 的值在进行传递，并进行运算，就只会递增一次。

 */

/*
 C++中内联编译的限制：
 
 不能存在任何形式的循环语句 ；
 
 不能存在过多的条件判断语句；
 
 函数体不能过于庞大；
 
 不能对函数进行取址操作；
 
 函数内联声明必须在调用语句之前；
 编译器对于内联函数的限制并不是绝对的，内联函数相对于普通函数的优势只是省去了函数调用时压栈，跳转和返回的开销。因此，当函数体的执行开销远大于压栈，跳转和返回所用的开销时，那么内联将无意义。
 
 */

/*
 结论：
 1）内联函数在编译时直接将函数体插入函数调用的地方。
 
 2）inline只是一种请求，编译器不一定允许这种请求。
 
 3）内联函数省去了普通函数调用时压栈，跳转和返回的开销。
 */

using namespace std;

#define MyAdd(a, b) ((a) + (b))

void test01()
{
    int ret = MyAdd(10, 20) * 30;
    cout << "ret = " << ret << endl;
}

#define MyCompare(a, b) ((a) > (b) ? (a) : (b))

inline void myCompare(int a, int b)
{
    int ret = a > b ? a : b;
    cout << "ret = " << ret << endl;
}

// 内联函数注意事项：
// 1.类内部的函数，默认会加入inline关键字
inline void func(); // 内联函数声明
inline void func() {} // 内联函数实现，如果函数声明时使用inline，实现时未使用inline，那么这个函数依旧不是内联函数

void test02()
{
    myCompare(10, 20);
}

int main(int argc, const char *argv[])
{
    test01();
    return EXIT_SUCCESS;
}
